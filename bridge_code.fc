() recv_external(slice in_msg) impure {
}


(cell) get_current_oracle_set() {
  ;;//TODO
  return begin_cell().end_cell();
}


((cell, cell, int), (int, int, cell)) ~check_update ((cell, cell, int) data) {
  (cell sets, cell candidates, int current_set_hash) = data;
  cell config_set = get_current_oracle_set();
  int config_set_hash = cell_hash(config_set);
  int set_updated? = current_set_hash != config_set_hash;
  slice config_set_data = config_set.begin_parse();
  (int flat_stake, 
   int min_auth_num,
   int seqno,
   cell oracles) = (config_set_data~load_grams(),
                    config_set_data~load_uint(16),
                    config_set_data~load_uint(32),
                    config_set_data~load_dict());
  cell oracle_keys = new_dict();
  if (set_updated?) {
    current_set_hash = config_set_hash;
    int unrewarded_stake = 0;
    cell locked_stakes = new_dict();
    int _ind = -1;
    do {
      (_ind, slice oracle_id_, int found?) = oracles.udict_get_next?(256, _ind);
      if (found?) {
        int oracle_id = oracle_id_~load_uint(256);
        (slice candidate, int found_candidate?) = candidates~udict_delete_get?(256, oracle_id);
        slice candidate_copy = candidate;
        if(found_candidate?) {
          (int credit, slice pubkeys) = (candidate~load_grams(),
                                         candidate~load_bits(512));
          if(credit >= flat_stake) {
            credit = credit - flat_stake;
            builder new_candidate = begin_cell()
                                    .store_grams(credit)
                                    .store_slice(pubkeys);
            candidates~udict_set_builder(256, oracle_id, new_candidate);
            oracle_keys~udict_set(256, oracle_id, pubkeys);
            unrewarded_stake = unrewarded_stake + flat_stake;
            locked_stakes~udict_set_builder(256, oracle_id, begin_cell().store_grams(flat_stake));
          } else {
            candidates~udict_set(256, oracle_id, candidate_copy);
          }
        }
      }
    } until (~ found?);
    ;; //TODO check number of oracles
    ;; throw_if( 314, (unrewarded_stake / flat_stake) < 4);
    builder oracle_set_data = begin_cell()
                              .store_uint(1,1)
                              .store_grams(unrewarded_stake)
                              .store_grams(0)
                              .store_uint(min_auth_num,16)
                              .store_dict(oracle_keys)
                              .store_dict(locked_stakes)
                              .store_dict(new_dict()); ;; complaints
                              
    (sets, int success?) = sets.udict_add_builder?(256, current_set_hash, oracle_set_data);
    ;; Exception will be thrown if existed and non removed set are going to be rewritten
    ;; and it's data (credits) will be lost in this case we will effectively pause bridge
    ;; contract till validators set correct oracle set
    throw_unless(312, success?);
  } else {
    slice sets_s = sets.begin_parse();
    oracle_keys = sets_s~load_ref(); ;; No need to parse and load_dict
  }
  return ((sets, candidates, current_set_hash), (set_updated?, min_auth_num, oracle_keys));
}

() deposit_stake(int msg_value, int ed_pubkey, int secp_pubkey, slice s_addr, int query_id, int is_text) impure {
    (int total_stake, int _2, int current_set_hash, cell sets, cell candidates, cell _6, cell _7) = load_data();
    (sets, candidates, current_set_hash)~check_update();
    (int src_wc, int src_addr_hash) = parse_std_addr(s_addr);
    throw_if(301, src_wc + 1); ;; not from masterchain, return error
    int fee = 1000000000;
    throw_if(302, msg_value < fee);
    int amount = msg_value - fee;
    (slice candidate, int found?) = candidates~udict_delete_get?(256, src_addr_hash);
    int credit = 0;
    if (found?) {
      credit = candidate~load_grams();
      ;; To change pubkey withdraw all grams first
      throw_unless( 303, (ed_pubkey == candidate~load_uint(256)) & (secp_pubkey == candidate~load_uint(256)) );
    }
    credit = credit + amount;
    total_stake = total_stake + amount;
    builder new_candidate_data = begin_cell()
                            .store_grams(credit)
                            .store_uint(ed_pubkey, 256)
                            .store_uint(secp_pubkey, 256);
    candidates~udict_set_builder(256, src_addr_hash, new_candidate_data);
    save_data(total_stake, _2, current_set_hash, sets, candidates, _6, _7);
    if(is_text) {
      tuple OK = pair_ints(2, 0x4f4b);
      tuple list = cons(OK, cons(encode_number_to_text(amount), empty_tuple()));
      return send_text_receipt_message(s_addr, list, fee / 10, 2);
    } else {
      return send_receipt_message(s_addr, 0x10000 + 1, query_id, 0, fee / 10, 2);
    }
}

() withdraw_stake(int amount, slice s_addr, int query_id, int is_text) impure {
    (int total_stake, int _2, int current_set_hash, cell sets, cell candidates, cell _6, cell _7) = load_data();
    (sets, candidates, current_set_hash)~check_update();
    (int src_wc, int src_addr_hash) = parse_std_addr(s_addr);
    throw_if(301, src_wc + 1); ;; not from masterchain, return error
    int fee = 1000000000;
    throw_if(302, amount < fee);
    (slice candidate, int found?) = candidates~udict_delete_get?(256, src_addr_hash);
    throw_unless(304, found?);
    int credit = candidate~load_grams();
    credit = credit - amount;
    total_stake = total_stake - amount;
    if(credit > 0) {
      builder new_candidate_data = begin_cell()
                              .store_grams(credit)
                              .store_slice(candidate);
      candidates~udict_set_builder(256, src_addr_hash, new_candidate_data);
    }
    save_data(total_stake, _2, current_set_hash, sets, candidates, _6, _7);
    if(is_text) {
      tuple OK = pair_ints(2, 0x4f4b);
      tuple list = cons(OK, cons(encode_number_to_text(amount), empty_tuple()));
      return send_text_receipt_message(s_addr, list, amount - fee, 2);
    } else {
      return send_receipt_message(s_addr, 0x10000 + 2, query_id, 0, amount - fee, 2);
    }
}


(int) execute_swap (slice swap_data) impure {
  (int ext_chain_hash,
   int wc,
   int addr_hash,
   int amount) = (swap_data~load_uint(256),
                  swap_data~load_int(8),
                  swap_data~load_uint(256),
                  swap_data~load_uint(64));
  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_uint(4, 3).store_int(wc, 8).store_uint(addr_hash, 256)
    .store_grams(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(ext_chain_hash, 256); ;;// TODO send ext_chain_hash as text
  send_raw_message(msg.end_cell(), 0);
  return amount;
}


() create_swap_from_ton(int destination_address, int amount, slice s_addr, int query_id, int is_text) impure {
    ;; create swap to external chain to destination address
    amount = amount - swap_to_ext_chain_fee(amount);
    throw_unless(306, amount > 0);    
    (int _1, int total_locked, int current_set_hash, cell sets, cell candidates, cell outcoming_swaps, cell _7) = load_data();
    (sets, candidates, current_set_hash)~check_update();
    int id = cur_lt();
    builder new_outcoming_swap = begin_cell()
                                .store_grams(amount)
                                .store_uint(destination_address, 160)
                                .store_uint(current_set_hash, 256)
                                .store_dict(new_dict());
    outcoming_swaps~udict_set_builder(64, id, new_outcoming_swap);
    total_locked = total_locked + amount;
    emit_log_simple(0xc0470ccf, begin_cell().store_uint(destination_address, 160).store_uint(amount, 64).end_cell().begin_parse());
    save_data(_1, total_locked, current_set_hash, sets, candidates, outcoming_swaps, _7);
    if(is_text) {
      tuple OK = pair_ints(2, 0x4f4b);
      tuple list = cons(OK, empty_tuple());
      return send_text_receipt_message(s_addr, list, 0, 64 + 2);
    } else {
      return send_receipt_message(s_addr, 0x10000 + 3, query_id, 0, 0, 64);
    }
}

() create_swap_to_ton(int wc, int addr_hash, int ext_chain_tx_hash, int amount, slice s_addr, int query_id, int is_text) impure {
    (int _1, int total_locked, int current_set_hash, cell sets, cell candidates, cell _6, cell incoming_swaps) = load_data();
    (sets, candidates, current_set_hash)~check_update();
    slice swap_id_seed = begin_cell()
                          .store_uint(ext_chain_tx_hash, 256)
                          .store_int(wc, 8)
                          .store_uint(addr_hash, 256)
                          .store_uint(amount, 64)
                         .end_cell().begin_parse();
    int swap_id = string_hash(swap_id_seed);
    builder incoming_swap = begin_cell()
                            .store_slice(swap_id_seed)
                            .store_uint(current_set_hash, 256)
                            .store_uint(0, 16)
                            .store_dict(new_dict());
    (incoming_swaps, int success?) = incoming_swaps.udict_add_builder?(256, swap_id, incoming_swap);
    throw_unless(307, success?);
    save_data(_1, total_locked, current_set_hash, sets, candidates, _6, incoming_swaps);
    if(is_text) {
      tuple OK = pair_ints(2, 0x4f4b);
      tuple list = cons(OK, empty_tuple());
      return send_text_receipt_message(s_addr, list, 0, 64 + 2);
    } else {
      return send_receipt_message(s_addr, 0x10000 + 4, query_id, 0, 0, 64 + 2);
    }
}

(int, int) get_ed_key(cell oracle_keys, oracle_id) {
  (slice keys, int found?) = oracle_keys.udict_get?(256, oracle_id);
  int key = 0;
  if(found?) {
    key = keys~load_uint(256);
  }
  return (key, found?);
}

(int, int) get_secp_key(cell oracle_keys, oracle_id) {
  (slice keys, int found?) = oracle_keys.udict_get?(256, oracle_id);
  int key = 0;
  if(found?) {
    key = keys~load_uint(256); ;; forget ed
    key = keys~load_uint(256);
  }
  return (key, found?);
}

(cell, ()) ~remove_outdated_authorizations (cell authorizations, cell new_oracle_keys) {
    cell new_auths = new_dict();
    int oracle_id = -1;
    do {
      (oracle_id, slice true_slice, int found?) = authorizations.udict_get_next?(256, oracle_id);
      if (found?) {
        (int __, int oracle_key_found?) = new_oracle_keys.get_ed_key(oracle_id);
        if(oracle_key_found?) {
          new_auths~udict_set(256, oracle_id, true_slice);
        }
      }
    } until (~ found?);
    return (new_auths, ());
}

() submit_signatures_for_ton(slice in_msg, slice s_addr, int query_id) {
    int swap_id = in_msg~load_uint(256);
    cell signatures = in_msg~load_dict();
    (int _1, int total_locked, int current_set_hash, cell sets, cell candidates, cell _6, cell incoming_swaps) = load_data();
    (int set_updated?, int min_auth_num, cell oracle_keys) = (sets, candidates, current_set_hash)~check_update();
    (slice old_swap_data, int found?) = incoming_swaps~udict_delete_get?(256, swap_id);
    throw_unless(308, found?);
    slice swap_body = old_swap_data~load_bits(256 + 8 + 256 + 64);
    int auth_num = old_swap_data~load_uint(16);
    cell authorizations = old_swap_data~load_dict();
    if(set_updated?) {
      ;; remove signatures signed by oracle not presented in current set
      authorizations~remove_outdated_authorizations(oracle_keys);
    }
    int oracle_id = -1;
    do {
      (oracle_id, slice sig, int found?) = signatures.udict_get_next?(256, oracle_id);
      if (found?) {
        (int key, int oracle_key_found?) = oracle_keys.get_ed_key(oracle_id);
        throw_unless(0x10000 + 34, oracle_key_found?);
        throw_unless(34, check_signature(swap_id, sig, key));
        (authorizations, int success?) = authorizations.udict_add_builder?(256, oracle_id, begin_cell().store_uint(1,1));
        if(success?) {
          auth_num = auth_num + 1;
        }
      }
    } until (~ found?);
    int body = 0;
    if(auth_num > min_auth_num) {
      int unlocked = execute_swap(swap_body);
      total_locked = total_locked - unlocked;
      body = 1;
    } else {
      builder incoming_swap = begin_cell()
                              .store_slice(swap_body)
                              .store_uint(current_set_hash, 256)
                              .store_uint(auth_num, 16)
                              .store_dict(authorizations);
      (incoming_swaps, int success?) = incoming_swaps.udict_replace_builder?(256, swap_id, incoming_swap);
      throw_unless(308, success?);
    }
    save_data(_1, total_locked, current_set_hash, sets, candidates, _6, incoming_swaps);
    return send_receipt_message(s_addr, 0x10000 + 5, query_id, body, 0, 64 + 2);
}

() submit_signatures_for_external_chain(slice in_msg, slice s_addr, int query_id) {
    int swap_id = in_msg~load_uint(64);
    cell signatures = in_msg~load_dict();
    (int _1, int total_locked, int current_set_hash, cell sets, cell candidates, cell outcoming_swaps, cell _7) = load_data();
    (int set_updated?, int min_auth_num, cell oracle_keys) = (sets, candidates, current_set_hash)~check_update();
    (slice old_swap_data, int found?) = outcoming_swaps~udict_delete_get?(64, swap_id);
    throw_unless(309, found?);
    (int outcoming_token_amount,
     int ext_chain_address,
     int _outdated_set_hash,
     cell  stored_signatures) = (old_swap_data~load_grams(),
                                 old_swap_data~load_uint(256),
                                 old_swap_data~load_uint(256),
                                 old_swap_data~load_dict());
    int oracle_id = -1;
    do {
      (oracle_id, slice sig, int found?) = signatures.udict_get_next?(256, oracle_id);
      ;; //NOTE we cannot check secp signatures, thus we cannot trust mass signatures storing
      ;; //for secp, signatures can be sumbited only by oracles themselves for authorization
      (int src_wc, int src_addr_hash) = parse_std_addr(s_addr);
      throw_unless(310, (oracle_id == src_addr_hash) & (src_wc == -1));
      if (found?) {
        (int secp_key, int key_found?) = oracle_keys.get_secp_key(oracle_id);
        if(key_found?) {
          stored_signatures~udict_set(256, secp_key, sig);
        }
      }
    } until (~ found?);
    builder outcoming_swap = begin_cell()
                              .store_grams(outcoming_token_amount)
                              .store_uint(ext_chain_address, 160)
                              .store_uint(current_set_hash, 256)
                              .store_dict(stored_signatures);
    (outcoming_swaps, int success?) = outcoming_swaps.udict_replace_builder?(256, swap_id, outcoming_swap);
    throw_unless(311, success?);
    save_data(_1, total_locked, current_set_hash, sets, candidates, outcoming_swaps, _7);
    return send_receipt_message(s_addr, 0x10000 + 5, query_id, 0, 0, 64 + 2);
}

() submit_signatures(slice in_msg, slice s_addr, int query_id) {
    int swap_to_ton? = in_msg~load_uint(1);
    if(swap_to_ton?) {
      return submit_signatures_for_ton(in_msg, s_addr, query_id);
    } else {
      return submit_signatures_for_external_chain(in_msg, s_addr, query_id);
    }
}

() vote_for_complaint(slice in_msg, int msg_value, slice s_addr, int query_id) {
}

() vote_for_set_stake(slice in_msg, int msg_value, slice s_addr, int query_id) {
}

() process_comment_api_request (slice in_msg, int msg_value, slice s_addr) {
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
  var cs = in_msg_cell.begin_parse();
  var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  if (flags & 1) {
    ;; ignore all bounced messages
    return ();
  }
  slice s_addr = cs~load_msg_addr();
  if (in_msg.slice_empty?()) {
    ;; inbound message has empty body
    throw(299);
  }
  int op = in_msg~load_uint(32);
  if (op == 0) {
    return process_comment_api_request(in_msg, msg_value, s_addr);
  }
  int query_id = in_msg~load_uint(64);
  if (op == 1) {
    ;; deposit stake
    if (in_msg.slice_empty?() & (in_msg.slice_refs() == 1)) {
      cell _cont = in_msg~load_ref();
      in_msg = _cont.begin_parse();
    }
    (int ed_publey, int secp_pubkey) = (in_msg~load_uint(256), in_msg~load_uint(256));
    return deposit_stake(msg_value, ed_publey, secp_pubkey, s_addr, query_id, false);
  }
  if (op == 2) {
    ;; withdraw stake
    int amount = in_msg~load_grams();
    return withdraw_stake(amount, s_addr, query_id, false);
  }
  if (op == 3) {
    int destination_address = in_msg~load_uint(160);
    return create_swap_from_ton(destination_address, msg_value, s_addr, query_id, false);
  }
  if (op == 4) {
    ;; create swap to TON
    int wc = in_msg~load_int(8);
    int address = in_msg~load_uint(256);
    int amount = in_msg~load_grams();
    int ext_chain_tx_hash = in_msg~load_uint(256); 
    return create_swap_to_ton(wc, address, amount, ext_chain_tx_hash, s_addr, query_id, false);
  }
  ;; Non-text API only
  if (op == 5) {
    ;; submit signatures
  }
  if (op == 6) {
    ;; vote for complaint
    return vote_for_complaint(in_msg, msg_value, s_addr, query_id);
  }
  if (op == 7) {
    ;; vote for set stakes release
    return vote_for_set_stake(in_msg, msg_value, s_addr, query_id);
  }

}
